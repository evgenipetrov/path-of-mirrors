/**
 * Generated by orval v7.16.1 üç∫
 * Do not edit manually.
 * Path of Mirrors
 * Path of Exile economic intelligence platform
 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'
import { apiClient } from '../../../lib/api-client'
import type {
  AnalysisHealthApiV1GameAnalysisHealthGet200,
  BuildAnalysisRequest,
  BuildAnalysisResponse,
  BuildsHealthApiV1GameBuildsHealthGet200,
  CatalogHealthApiV1GameCatalogHealthGet200,
  EconomyHealthApiV1GameItemsHealthGet200,
  Game,
  HTTPValidationError,
  HealthCheckHealthGet200,
  ItemSearchRequest,
  ItemSearchResponse,
  NoteCreate,
  NoteResponse,
  NoteUpdate,
  NotesHealthApiV1GameNotesHealthGet200,
  PoBParseRequest,
  PobHealthApiV1GamePobHealthGet200,
  RankRequest,
  RankResponse,
  SrcContextsBuildsDomainSchemasPoBParseResponse,
  SrcContextsUpstreamDomainSchemasPoBParseResponse,
  StatDefinitionsResponse,
} from './pathOfMirrors.schemas'

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * Notes context health check.

Args:
    game: Game context (poe1 or poe2).

Returns:
    Health status.
 * @summary notes context healthcheck
 */
export const notesHealthApiV1GameNotesHealthGet = (
  game: Game,
  options?: SecondParameter<typeof apiClient>,
  signal?: AbortSignal
) => {
  return apiClient<NotesHealthApiV1GameNotesHealthGet200>(
    { url: `/api/v1/${game}/notes/health`, method: 'GET', signal },
    options
  )
}

export const getNotesHealthApiV1GameNotesHealthGetQueryKey = (game?: Game) => {
  return [`/api/v1/${game}/notes/health`] as const
}

export const getNotesHealthApiV1GameNotesHealthGetQueryOptions = <
  TData = Awaited<ReturnType<typeof notesHealthApiV1GameNotesHealthGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof notesHealthApiV1GameNotesHealthGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof apiClient>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getNotesHealthApiV1GameNotesHealthGetQueryKey(game)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof notesHealthApiV1GameNotesHealthGet>>
  > = ({ signal }) =>
    notesHealthApiV1GameNotesHealthGet(game, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!game,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof notesHealthApiV1GameNotesHealthGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type NotesHealthApiV1GameNotesHealthGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof notesHealthApiV1GameNotesHealthGet>>
>
export type NotesHealthApiV1GameNotesHealthGetQueryError = HTTPValidationError

export function useNotesHealthApiV1GameNotesHealthGet<
  TData = Awaited<ReturnType<typeof notesHealthApiV1GameNotesHealthGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof notesHealthApiV1GameNotesHealthGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof notesHealthApiV1GameNotesHealthGet>>,
          TError,
          Awaited<ReturnType<typeof notesHealthApiV1GameNotesHealthGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useNotesHealthApiV1GameNotesHealthGet<
  TData = Awaited<ReturnType<typeof notesHealthApiV1GameNotesHealthGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof notesHealthApiV1GameNotesHealthGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof notesHealthApiV1GameNotesHealthGet>>,
          TError,
          Awaited<ReturnType<typeof notesHealthApiV1GameNotesHealthGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useNotesHealthApiV1GameNotesHealthGet<
  TData = Awaited<ReturnType<typeof notesHealthApiV1GameNotesHealthGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof notesHealthApiV1GameNotesHealthGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary notes context healthcheck
 */

export function useNotesHealthApiV1GameNotesHealthGet<
  TData = Awaited<ReturnType<typeof notesHealthApiV1GameNotesHealthGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof notesHealthApiV1GameNotesHealthGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getNotesHealthApiV1GameNotesHealthGetQueryOptions(
    game,
    options
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create a new note.

Args:
    game: Game context (poe1 or poe2).
    note_data: Note creation data.
    service: Note service dependency.

Returns:
    NoteResponse: Created note.
 * @summary Create a new note
 */
export const createNoteApiV1GameNotesPost = (
  game: Game,
  noteCreate: NoteCreate,
  options?: SecondParameter<typeof apiClient>,
  signal?: AbortSignal
) => {
  return apiClient<NoteResponse>(
    {
      url: `/api/v1/${game}/notes`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: noteCreate,
      signal,
    },
    options
  )
}

export const getCreateNoteApiV1GameNotesPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNoteApiV1GameNotesPost>>,
    TError,
    { game: Game; data: NoteCreate },
    TContext
  >
  request?: SecondParameter<typeof apiClient>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNoteApiV1GameNotesPost>>,
  TError,
  { game: Game; data: NoteCreate },
  TContext
> => {
  const mutationKey = ['createNoteApiV1GameNotesPost']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNoteApiV1GameNotesPost>>,
    { game: Game; data: NoteCreate }
  > = (props) => {
    const { game, data } = props ?? {}

    return createNoteApiV1GameNotesPost(game, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateNoteApiV1GameNotesPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNoteApiV1GameNotesPost>>
>
export type CreateNoteApiV1GameNotesPostMutationBody = NoteCreate
export type CreateNoteApiV1GameNotesPostMutationError = HTTPValidationError

/**
 * @summary Create a new note
 */
export const useCreateNoteApiV1GameNotesPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createNoteApiV1GameNotesPost>>,
      TError,
      { game: Game; data: NoteCreate },
      TContext
    >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createNoteApiV1GameNotesPost>>,
  TError,
  { game: Game; data: NoteCreate },
  TContext
> => {
  const mutationOptions =
    getCreateNoteApiV1GameNotesPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * List all notes for the specified game.

Args:
    game: Game context (poe1 or poe2).
    service: Note service dependency.

Returns:
    list[NoteResponse]: List of notes.
 * @summary List all notes
 */
export const listNotesApiV1GameNotesGet = (
  game: Game,
  options?: SecondParameter<typeof apiClient>,
  signal?: AbortSignal
) => {
  return apiClient<NoteResponse[]>(
    { url: `/api/v1/${game}/notes`, method: 'GET', signal },
    options
  )
}

export const getListNotesApiV1GameNotesGetQueryKey = (game?: Game) => {
  return [`/api/v1/${game}/notes`] as const
}

export const getListNotesApiV1GameNotesGetQueryOptions = <
  TData = Awaited<ReturnType<typeof listNotesApiV1GameNotesGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listNotesApiV1GameNotesGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof apiClient>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getListNotesApiV1GameNotesGetQueryKey(game)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof listNotesApiV1GameNotesGet>>
  > = ({ signal }) => listNotesApiV1GameNotesGet(game, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!game,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof listNotesApiV1GameNotesGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListNotesApiV1GameNotesGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof listNotesApiV1GameNotesGet>>
>
export type ListNotesApiV1GameNotesGetQueryError = HTTPValidationError

export function useListNotesApiV1GameNotesGet<
  TData = Awaited<ReturnType<typeof listNotesApiV1GameNotesGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listNotesApiV1GameNotesGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listNotesApiV1GameNotesGet>>,
          TError,
          Awaited<ReturnType<typeof listNotesApiV1GameNotesGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListNotesApiV1GameNotesGet<
  TData = Awaited<ReturnType<typeof listNotesApiV1GameNotesGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listNotesApiV1GameNotesGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listNotesApiV1GameNotesGet>>,
          TError,
          Awaited<ReturnType<typeof listNotesApiV1GameNotesGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListNotesApiV1GameNotesGet<
  TData = Awaited<ReturnType<typeof listNotesApiV1GameNotesGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listNotesApiV1GameNotesGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary List all notes
 */

export function useListNotesApiV1GameNotesGet<
  TData = Awaited<ReturnType<typeof listNotesApiV1GameNotesGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listNotesApiV1GameNotesGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getListNotesApiV1GameNotesGetQueryOptions(game, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get a note by ID.

Args:
    game: Game context (poe1 or poe2).
    note_id: Note ID.
    service: Note service dependency.

Returns:
    NoteResponse: Note.

Raises:
    HTTPException: 404 if note not found.
 * @summary Get a note by ID
 */
export const getNoteApiV1GameNotesNoteIdGet = (
  game: Game,
  noteId: string,
  options?: SecondParameter<typeof apiClient>,
  signal?: AbortSignal
) => {
  return apiClient<NoteResponse>(
    { url: `/api/v1/${game}/notes/${noteId}`, method: 'GET', signal },
    options
  )
}

export const getGetNoteApiV1GameNotesNoteIdGetQueryKey = (
  game?: Game,
  noteId?: string
) => {
  return [`/api/v1/${game}/notes/${noteId}`] as const
}

export const getGetNoteApiV1GameNotesNoteIdGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getNoteApiV1GameNotesNoteIdGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  noteId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getNoteApiV1GameNotesNoteIdGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof apiClient>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetNoteApiV1GameNotesNoteIdGetQueryKey(game, noteId)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNoteApiV1GameNotesNoteIdGet>>
  > = ({ signal }) =>
    getNoteApiV1GameNotesNoteIdGet(game, noteId, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!(game && noteId),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getNoteApiV1GameNotesNoteIdGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetNoteApiV1GameNotesNoteIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNoteApiV1GameNotesNoteIdGet>>
>
export type GetNoteApiV1GameNotesNoteIdGetQueryError = HTTPValidationError

export function useGetNoteApiV1GameNotesNoteIdGet<
  TData = Awaited<ReturnType<typeof getNoteApiV1GameNotesNoteIdGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  noteId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getNoteApiV1GameNotesNoteIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNoteApiV1GameNotesNoteIdGet>>,
          TError,
          Awaited<ReturnType<typeof getNoteApiV1GameNotesNoteIdGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetNoteApiV1GameNotesNoteIdGet<
  TData = Awaited<ReturnType<typeof getNoteApiV1GameNotesNoteIdGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  noteId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getNoteApiV1GameNotesNoteIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNoteApiV1GameNotesNoteIdGet>>,
          TError,
          Awaited<ReturnType<typeof getNoteApiV1GameNotesNoteIdGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetNoteApiV1GameNotesNoteIdGet<
  TData = Awaited<ReturnType<typeof getNoteApiV1GameNotesNoteIdGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  noteId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getNoteApiV1GameNotesNoteIdGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get a note by ID
 */

export function useGetNoteApiV1GameNotesNoteIdGet<
  TData = Awaited<ReturnType<typeof getNoteApiV1GameNotesNoteIdGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  noteId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getNoteApiV1GameNotesNoteIdGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetNoteApiV1GameNotesNoteIdGetQueryOptions(
    game,
    noteId,
    options
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update an existing note.

Args:
    game: Game context (poe1 or poe2).
    note_id: Note ID.
    note_data: Note update data.
    service: Note service dependency.

Returns:
    NoteResponse: Updated note.

Raises:
    HTTPException: 404 if note not found or wrong game context.
 * @summary Update a note
 */
export const updateNoteApiV1GameNotesNoteIdPut = (
  game: Game,
  noteId: string,
  noteUpdate: NoteUpdate,
  options?: SecondParameter<typeof apiClient>
) => {
  return apiClient<NoteResponse>(
    {
      url: `/api/v1/${game}/notes/${noteId}`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: noteUpdate,
    },
    options
  )
}

export const getUpdateNoteApiV1GameNotesNoteIdPutMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateNoteApiV1GameNotesNoteIdPut>>,
    TError,
    { game: Game; noteId: string; data: NoteUpdate },
    TContext
  >
  request?: SecondParameter<typeof apiClient>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateNoteApiV1GameNotesNoteIdPut>>,
  TError,
  { game: Game; noteId: string; data: NoteUpdate },
  TContext
> => {
  const mutationKey = ['updateNoteApiV1GameNotesNoteIdPut']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateNoteApiV1GameNotesNoteIdPut>>,
    { game: Game; noteId: string; data: NoteUpdate }
  > = (props) => {
    const { game, noteId, data } = props ?? {}

    return updateNoteApiV1GameNotesNoteIdPut(game, noteId, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateNoteApiV1GameNotesNoteIdPutMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateNoteApiV1GameNotesNoteIdPut>>
>
export type UpdateNoteApiV1GameNotesNoteIdPutMutationBody = NoteUpdate
export type UpdateNoteApiV1GameNotesNoteIdPutMutationError = HTTPValidationError

/**
 * @summary Update a note
 */
export const useUpdateNoteApiV1GameNotesNoteIdPut = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateNoteApiV1GameNotesNoteIdPut>>,
      TError,
      { game: Game; noteId: string; data: NoteUpdate },
      TContext
    >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateNoteApiV1GameNotesNoteIdPut>>,
  TError,
  { game: Game; noteId: string; data: NoteUpdate },
  TContext
> => {
  const mutationOptions =
    getUpdateNoteApiV1GameNotesNoteIdPutMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Delete a note.

Args:
    game: Game context (poe1 or poe2).
    note_id: Note ID.
    service: Note service dependency.

Raises:
    HTTPException: 404 if note not found.
 * @summary Delete a note
 */
export const deleteNoteApiV1GameNotesNoteIdDelete = (
  game: Game,
  noteId: string,
  options?: SecondParameter<typeof apiClient>
) => {
  return apiClient<void>(
    { url: `/api/v1/${game}/notes/${noteId}`, method: 'DELETE' },
    options
  )
}

export const getDeleteNoteApiV1GameNotesNoteIdDeleteMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteNoteApiV1GameNotesNoteIdDelete>>,
    TError,
    { game: Game; noteId: string },
    TContext
  >
  request?: SecondParameter<typeof apiClient>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteNoteApiV1GameNotesNoteIdDelete>>,
  TError,
  { game: Game; noteId: string },
  TContext
> => {
  const mutationKey = ['deleteNoteApiV1GameNotesNoteIdDelete']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteNoteApiV1GameNotesNoteIdDelete>>,
    { game: Game; noteId: string }
  > = (props) => {
    const { game, noteId } = props ?? {}

    return deleteNoteApiV1GameNotesNoteIdDelete(game, noteId, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteNoteApiV1GameNotesNoteIdDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteNoteApiV1GameNotesNoteIdDelete>>
>

export type DeleteNoteApiV1GameNotesNoteIdDeleteMutationError =
  HTTPValidationError

/**
 * @summary Delete a note
 */
export const useDeleteNoteApiV1GameNotesNoteIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteNoteApiV1GameNotesNoteIdDelete>>,
      TError,
      { game: Game; noteId: string },
      TContext
    >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteNoteApiV1GameNotesNoteIdDelete>>,
  TError,
  { game: Game; noteId: string },
  TContext
> => {
  const mutationOptions =
    getDeleteNoteApiV1GameNotesNoteIdDeleteMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * PoB context health check.

Args:
    game: Game context (poe1 or poe2).

Returns:
    Health status.
 * @summary pob context healthcheck
 */
export const pobHealthApiV1GamePobHealthGet = (
  game: Game,
  options?: SecondParameter<typeof apiClient>,
  signal?: AbortSignal
) => {
  return apiClient<PobHealthApiV1GamePobHealthGet200>(
    { url: `/api/v1/${game}/pob/health`, method: 'GET', signal },
    options
  )
}

export const getPobHealthApiV1GamePobHealthGetQueryKey = (game?: Game) => {
  return [`/api/v1/${game}/pob/health`] as const
}

export const getPobHealthApiV1GamePobHealthGetQueryOptions = <
  TData = Awaited<ReturnType<typeof pobHealthApiV1GamePobHealthGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pobHealthApiV1GamePobHealthGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof apiClient>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getPobHealthApiV1GamePobHealthGetQueryKey(game)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof pobHealthApiV1GamePobHealthGet>>
  > = ({ signal }) =>
    pobHealthApiV1GamePobHealthGet(game, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!game,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof pobHealthApiV1GamePobHealthGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PobHealthApiV1GamePobHealthGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof pobHealthApiV1GamePobHealthGet>>
>
export type PobHealthApiV1GamePobHealthGetQueryError = HTTPValidationError

export function usePobHealthApiV1GamePobHealthGet<
  TData = Awaited<ReturnType<typeof pobHealthApiV1GamePobHealthGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pobHealthApiV1GamePobHealthGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pobHealthApiV1GamePobHealthGet>>,
          TError,
          Awaited<ReturnType<typeof pobHealthApiV1GamePobHealthGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function usePobHealthApiV1GamePobHealthGet<
  TData = Awaited<ReturnType<typeof pobHealthApiV1GamePobHealthGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pobHealthApiV1GamePobHealthGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pobHealthApiV1GamePobHealthGet>>,
          TError,
          Awaited<ReturnType<typeof pobHealthApiV1GamePobHealthGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function usePobHealthApiV1GamePobHealthGet<
  TData = Awaited<ReturnType<typeof pobHealthApiV1GamePobHealthGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pobHealthApiV1GamePobHealthGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary pob context healthcheck
 */

export function usePobHealthApiV1GamePobHealthGet<
  TData = Awaited<ReturnType<typeof pobHealthApiV1GamePobHealthGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pobHealthApiV1GamePobHealthGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getPobHealthApiV1GamePobHealthGetQueryOptions(
    game,
    options
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Parse Path of Building file or import code into standardized Build object.

This is a universal endpoint that can be used by any feature:
- Upgrade Finder: Parse build, extract current items, find better ones
- Deal Finder: Parse build, identify item requirements, find deals
- Meta Analyzer: Parse ladder builds, analyze trends

Args:
    game: Game context (poe1 or poe2).
    request: PoB parsing request with either XML or import code

Returns:
    Standardized Build object with character info and items

Raises:
    HTTPException 400: If neither pob_xml nor pob_code is provided
    HTTPException 422: If PoB data is invalid or cannot be parsed

Example:
    POST /api/v1/poe1/pob/parse
    {
        "pob_code": "eNqVW2uT2zYS..."
    }

    Response:
    {
        "game": "poe1",
        "name": "RF Juggernaut",
        "character_class": "Marauder",
        "level": 95,
        "items": {...}
    }
 * @summary Parse Pob
 */
export const parsePobApiV1GamePobParsePost = (
  game: Game,
  poBParseRequest: PoBParseRequest,
  options?: SecondParameter<typeof apiClient>,
  signal?: AbortSignal
) => {
  return apiClient<SrcContextsUpstreamDomainSchemasPoBParseResponse>(
    {
      url: `/api/v1/${game}/pob/parse`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: poBParseRequest,
      signal,
    },
    options
  )
}

export const getParsePobApiV1GamePobParsePostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof parsePobApiV1GamePobParsePost>>,
    TError,
    { game: Game; data: PoBParseRequest },
    TContext
  >
  request?: SecondParameter<typeof apiClient>
}): UseMutationOptions<
  Awaited<ReturnType<typeof parsePobApiV1GamePobParsePost>>,
  TError,
  { game: Game; data: PoBParseRequest },
  TContext
> => {
  const mutationKey = ['parsePobApiV1GamePobParsePost']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof parsePobApiV1GamePobParsePost>>,
    { game: Game; data: PoBParseRequest }
  > = (props) => {
    const { game, data } = props ?? {}

    return parsePobApiV1GamePobParsePost(game, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ParsePobApiV1GamePobParsePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof parsePobApiV1GamePobParsePost>>
>
export type ParsePobApiV1GamePobParsePostMutationBody = PoBParseRequest
export type ParsePobApiV1GamePobParsePostMutationError = HTTPValidationError

/**
 * @summary Parse Pob
 */
export const useParsePobApiV1GamePobParsePost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof parsePobApiV1GamePobParsePost>>,
      TError,
      { game: Game; data: PoBParseRequest },
      TContext
    >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof parsePobApiV1GamePobParsePost>>,
  TError,
  { game: Game; data: PoBParseRequest },
  TContext
> => {
  const mutationOptions =
    getParsePobApiV1GamePobParsePostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Catalog context health check.

Args:
    game: Game context (poe1 or poe2).

Returns:
    Health status.
 * @summary catalog context healthcheck
 */
export const catalogHealthApiV1GameCatalogHealthGet = (
  game: Game,
  options?: SecondParameter<typeof apiClient>,
  signal?: AbortSignal
) => {
  return apiClient<CatalogHealthApiV1GameCatalogHealthGet200>(
    { url: `/api/v1/${game}/catalog/health`, method: 'GET', signal },
    options
  )
}

export const getCatalogHealthApiV1GameCatalogHealthGetQueryKey = (
  game?: Game
) => {
  return [`/api/v1/${game}/catalog/health`] as const
}

export const getCatalogHealthApiV1GameCatalogHealthGetQueryOptions = <
  TData = Awaited<ReturnType<typeof catalogHealthApiV1GameCatalogHealthGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof catalogHealthApiV1GameCatalogHealthGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof apiClient>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getCatalogHealthApiV1GameCatalogHealthGetQueryKey(game)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof catalogHealthApiV1GameCatalogHealthGet>>
  > = ({ signal }) =>
    catalogHealthApiV1GameCatalogHealthGet(game, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!game,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof catalogHealthApiV1GameCatalogHealthGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CatalogHealthApiV1GameCatalogHealthGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof catalogHealthApiV1GameCatalogHealthGet>>
>
export type CatalogHealthApiV1GameCatalogHealthGetQueryError =
  HTTPValidationError

export function useCatalogHealthApiV1GameCatalogHealthGet<
  TData = Awaited<ReturnType<typeof catalogHealthApiV1GameCatalogHealthGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof catalogHealthApiV1GameCatalogHealthGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof catalogHealthApiV1GameCatalogHealthGet>>,
          TError,
          Awaited<ReturnType<typeof catalogHealthApiV1GameCatalogHealthGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useCatalogHealthApiV1GameCatalogHealthGet<
  TData = Awaited<ReturnType<typeof catalogHealthApiV1GameCatalogHealthGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof catalogHealthApiV1GameCatalogHealthGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof catalogHealthApiV1GameCatalogHealthGet>>,
          TError,
          Awaited<ReturnType<typeof catalogHealthApiV1GameCatalogHealthGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useCatalogHealthApiV1GameCatalogHealthGet<
  TData = Awaited<ReturnType<typeof catalogHealthApiV1GameCatalogHealthGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof catalogHealthApiV1GameCatalogHealthGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary catalog context healthcheck
 */

export function useCatalogHealthApiV1GameCatalogHealthGet<
  TData = Awaited<ReturnType<typeof catalogHealthApiV1GameCatalogHealthGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof catalogHealthApiV1GameCatalogHealthGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getCatalogHealthApiV1GameCatalogHealthGetQueryOptions(
    game,
    options
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Economy context health check.

Args:
    game: Game context (poe1 or poe2).

Returns:
    Health status.
 * @summary economy context healthcheck
 */
export const economyHealthApiV1GameItemsHealthGet = (
  game: Game,
  options?: SecondParameter<typeof apiClient>,
  signal?: AbortSignal
) => {
  return apiClient<EconomyHealthApiV1GameItemsHealthGet200>(
    { url: `/api/v1/${game}/items/health`, method: 'GET', signal },
    options
  )
}

export const getEconomyHealthApiV1GameItemsHealthGetQueryKey = (
  game?: Game
) => {
  return [`/api/v1/${game}/items/health`] as const
}

export const getEconomyHealthApiV1GameItemsHealthGetQueryOptions = <
  TData = Awaited<ReturnType<typeof economyHealthApiV1GameItemsHealthGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof economyHealthApiV1GameItemsHealthGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof apiClient>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getEconomyHealthApiV1GameItemsHealthGetQueryKey(game)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof economyHealthApiV1GameItemsHealthGet>>
  > = ({ signal }) =>
    economyHealthApiV1GameItemsHealthGet(game, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!game,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof economyHealthApiV1GameItemsHealthGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EconomyHealthApiV1GameItemsHealthGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof economyHealthApiV1GameItemsHealthGet>>
>
export type EconomyHealthApiV1GameItemsHealthGetQueryError = HTTPValidationError

export function useEconomyHealthApiV1GameItemsHealthGet<
  TData = Awaited<ReturnType<typeof economyHealthApiV1GameItemsHealthGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof economyHealthApiV1GameItemsHealthGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof economyHealthApiV1GameItemsHealthGet>>,
          TError,
          Awaited<ReturnType<typeof economyHealthApiV1GameItemsHealthGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useEconomyHealthApiV1GameItemsHealthGet<
  TData = Awaited<ReturnType<typeof economyHealthApiV1GameItemsHealthGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof economyHealthApiV1GameItemsHealthGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof economyHealthApiV1GameItemsHealthGet>>,
          TError,
          Awaited<ReturnType<typeof economyHealthApiV1GameItemsHealthGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useEconomyHealthApiV1GameItemsHealthGet<
  TData = Awaited<ReturnType<typeof economyHealthApiV1GameItemsHealthGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof economyHealthApiV1GameItemsHealthGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary economy context healthcheck
 */

export function useEconomyHealthApiV1GameItemsHealthGet<
  TData = Awaited<ReturnType<typeof economyHealthApiV1GameItemsHealthGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof economyHealthApiV1GameItemsHealthGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getEconomyHealthApiV1GameItemsHealthGetQueryOptions(
    game,
    options
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Search for items on Trade API.

This is a direct proxy to the Trade API with simplified filtering.
It does NOT perform any ranking or analysis.

Args:
    game: Game context (poe1 or poe2).
    request: Search request parameters

Returns:
    List of items found
 * @summary Search Items
 */
export const searchItemsApiV1GameItemsSearchPost = (
  game: Game,
  itemSearchRequest: ItemSearchRequest,
  options?: SecondParameter<typeof apiClient>,
  signal?: AbortSignal
) => {
  return apiClient<ItemSearchResponse>(
    {
      url: `/api/v1/${game}/items/search`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: itemSearchRequest,
      signal,
    },
    options
  )
}

export const getSearchItemsApiV1GameItemsSearchPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof searchItemsApiV1GameItemsSearchPost>>,
    TError,
    { game: Game; data: ItemSearchRequest },
    TContext
  >
  request?: SecondParameter<typeof apiClient>
}): UseMutationOptions<
  Awaited<ReturnType<typeof searchItemsApiV1GameItemsSearchPost>>,
  TError,
  { game: Game; data: ItemSearchRequest },
  TContext
> => {
  const mutationKey = ['searchItemsApiV1GameItemsSearchPost']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof searchItemsApiV1GameItemsSearchPost>>,
    { game: Game; data: ItemSearchRequest }
  > = (props) => {
    const { game, data } = props ?? {}

    return searchItemsApiV1GameItemsSearchPost(game, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type SearchItemsApiV1GameItemsSearchPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof searchItemsApiV1GameItemsSearchPost>>
>
export type SearchItemsApiV1GameItemsSearchPostMutationBody = ItemSearchRequest
export type SearchItemsApiV1GameItemsSearchPostMutationError =
  HTTPValidationError

/**
 * @summary Search Items
 */
export const useSearchItemsApiV1GameItemsSearchPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof searchItemsApiV1GameItemsSearchPost>>,
      TError,
      { game: Game; data: ItemSearchRequest },
      TContext
    >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof searchItemsApiV1GameItemsSearchPost>>,
  TError,
  { game: Game; data: ItemSearchRequest },
  TContext
> => {
  const mutationOptions =
    getSearchItemsApiV1GameItemsSearchPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Parse Path of Building file or import code into standardized Build object.

This endpoint:
1. Parses PoB XML or import code
2. Stores the build in Redis session (1-hour TTL)
3. Returns parsed build data + session_id for subsequent requests

The session_id can be used with:
- /api/v1/{game}/builds/analyze - Get stat weights and priorities
- /api/v1/{game}/items/search - Find item upgrades (client-side composition)

Args:
    game: Game context (poe1 or poe2).
    request: PoB parsing request with either XML or import code

Returns:
    Parsed Build object with session_id
 * @summary Parse Build
 */
export const parseBuildApiV1GameBuildsParsePost = (
  game: Game,
  poBParseRequest: PoBParseRequest,
  options?: SecondParameter<typeof apiClient>,
  signal?: AbortSignal
) => {
  return apiClient<SrcContextsBuildsDomainSchemasPoBParseResponse>(
    {
      url: `/api/v1/${game}/builds/parse`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: poBParseRequest,
      signal,
    },
    options
  )
}

export const getParseBuildApiV1GameBuildsParsePostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof parseBuildApiV1GameBuildsParsePost>>,
    TError,
    { game: Game; data: PoBParseRequest },
    TContext
  >
  request?: SecondParameter<typeof apiClient>
}): UseMutationOptions<
  Awaited<ReturnType<typeof parseBuildApiV1GameBuildsParsePost>>,
  TError,
  { game: Game; data: PoBParseRequest },
  TContext
> => {
  const mutationKey = ['parseBuildApiV1GameBuildsParsePost']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof parseBuildApiV1GameBuildsParsePost>>,
    { game: Game; data: PoBParseRequest }
  > = (props) => {
    const { game, data } = props ?? {}

    return parseBuildApiV1GameBuildsParsePost(game, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ParseBuildApiV1GameBuildsParsePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof parseBuildApiV1GameBuildsParsePost>>
>
export type ParseBuildApiV1GameBuildsParsePostMutationBody = PoBParseRequest
export type ParseBuildApiV1GameBuildsParsePostMutationError =
  HTTPValidationError

/**
 * @summary Parse Build
 */
export const useParseBuildApiV1GameBuildsParsePost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof parseBuildApiV1GameBuildsParsePost>>,
      TError,
      { game: Game; data: PoBParseRequest },
      TContext
    >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof parseBuildApiV1GameBuildsParsePost>>,
  TError,
  { game: Game; data: PoBParseRequest },
  TContext
> => {
  const mutationOptions =
    getParseBuildApiV1GameBuildsParsePostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Analyze build to calculate stat weights and upgrade priorities.

This endpoint:
1. Loads build from Redis session
2. Detects build archetype (life/ES/hybrid)
3. Calculates recommended stat weights
4. Suggests upgrade priorities for each slot

Users can then modify these weights before searching for upgrades.

Args:
    game: Game context (poe1 or poe2).
    request: Analysis request with session_id

Returns:
    Build analysis with archetype, weights, and priorities
 * @summary Analyze Build Endpoint
 */
export const analyzeBuildEndpointApiV1GameBuildsAnalyzePost = (
  game: Game,
  buildAnalysisRequest: BuildAnalysisRequest,
  options?: SecondParameter<typeof apiClient>,
  signal?: AbortSignal
) => {
  return apiClient<BuildAnalysisResponse>(
    {
      url: `/api/v1/${game}/builds/analyze`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: buildAnalysisRequest,
      signal,
    },
    options
  )
}

export const getAnalyzeBuildEndpointApiV1GameBuildsAnalyzePostMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof analyzeBuildEndpointApiV1GameBuildsAnalyzePost>
      >,
      TError,
      { game: Game; data: BuildAnalysisRequest },
      TContext
    >
    request?: SecondParameter<typeof apiClient>
  }): UseMutationOptions<
    Awaited<ReturnType<typeof analyzeBuildEndpointApiV1GameBuildsAnalyzePost>>,
    TError,
    { game: Game; data: BuildAnalysisRequest },
    TContext
  > => {
    const mutationKey = ['analyzeBuildEndpointApiV1GameBuildsAnalyzePost']
    const { mutation: mutationOptions, request: requestOptions } = options
      ? options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof analyzeBuildEndpointApiV1GameBuildsAnalyzePost>
      >,
      { game: Game; data: BuildAnalysisRequest }
    > = (props) => {
      const { game, data } = props ?? {}

      return analyzeBuildEndpointApiV1GameBuildsAnalyzePost(
        game,
        data,
        requestOptions
      )
    }

    return { mutationFn, ...mutationOptions }
  }

export type AnalyzeBuildEndpointApiV1GameBuildsAnalyzePostMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof analyzeBuildEndpointApiV1GameBuildsAnalyzePost>>
  >
export type AnalyzeBuildEndpointApiV1GameBuildsAnalyzePostMutationBody =
  BuildAnalysisRequest
export type AnalyzeBuildEndpointApiV1GameBuildsAnalyzePostMutationError =
  HTTPValidationError

/**
 * @summary Analyze Build Endpoint
 */
export const useAnalyzeBuildEndpointApiV1GameBuildsAnalyzePost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof analyzeBuildEndpointApiV1GameBuildsAnalyzePost>
      >,
      TError,
      { game: Game; data: BuildAnalysisRequest },
      TContext
    >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof analyzeBuildEndpointApiV1GameBuildsAnalyzePost>>,
  TError,
  { game: Game; data: BuildAnalysisRequest },
  TContext
> => {
  const mutationOptions =
    getAnalyzeBuildEndpointApiV1GameBuildsAnalyzePostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Get canonical stat definitions for a specific game.

This endpoint provides the single source of truth for valid stat names,
categories, and default weights. Use this to populate stat selection UIs
and ensure consistency between frontend and backend.

Args:
    game: Game context (poe1 or poe2)

Returns:
    List of canonical stat definitions

Example:
    GET /api/v1/poe1/builds/stats

    Response:
    {
        "game": "poe1",
        "stats": [
            {
                "key": "life",
                "display_name": "Life",
                "category": "defense",
                "default_weight": 1.0
            },
            ...
        ]
    }
 * @summary Get Canonical Stats
 */
export const getCanonicalStatsApiV1GameBuildsStatsGet = (
  game: Game,
  options?: SecondParameter<typeof apiClient>,
  signal?: AbortSignal
) => {
  return apiClient<StatDefinitionsResponse>(
    { url: `/api/v1/${game}/builds/stats`, method: 'GET', signal },
    options
  )
}

export const getGetCanonicalStatsApiV1GameBuildsStatsGetQueryKey = (
  game?: Game
) => {
  return [`/api/v1/${game}/builds/stats`] as const
}

export const getGetCanonicalStatsApiV1GameBuildsStatsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getCanonicalStatsApiV1GameBuildsStatsGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCanonicalStatsApiV1GameBuildsStatsGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof apiClient>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetCanonicalStatsApiV1GameBuildsStatsGetQueryKey(game)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getCanonicalStatsApiV1GameBuildsStatsGet>>
  > = ({ signal }) =>
    getCanonicalStatsApiV1GameBuildsStatsGet(game, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!game,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getCanonicalStatsApiV1GameBuildsStatsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCanonicalStatsApiV1GameBuildsStatsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCanonicalStatsApiV1GameBuildsStatsGet>>
>
export type GetCanonicalStatsApiV1GameBuildsStatsGetQueryError =
  HTTPValidationError

export function useGetCanonicalStatsApiV1GameBuildsStatsGet<
  TData = Awaited<ReturnType<typeof getCanonicalStatsApiV1GameBuildsStatsGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCanonicalStatsApiV1GameBuildsStatsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCanonicalStatsApiV1GameBuildsStatsGet>>,
          TError,
          Awaited<ReturnType<typeof getCanonicalStatsApiV1GameBuildsStatsGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetCanonicalStatsApiV1GameBuildsStatsGet<
  TData = Awaited<ReturnType<typeof getCanonicalStatsApiV1GameBuildsStatsGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCanonicalStatsApiV1GameBuildsStatsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCanonicalStatsApiV1GameBuildsStatsGet>>,
          TError,
          Awaited<ReturnType<typeof getCanonicalStatsApiV1GameBuildsStatsGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetCanonicalStatsApiV1GameBuildsStatsGet<
  TData = Awaited<ReturnType<typeof getCanonicalStatsApiV1GameBuildsStatsGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCanonicalStatsApiV1GameBuildsStatsGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Canonical Stats
 */

export function useGetCanonicalStatsApiV1GameBuildsStatsGet<
  TData = Awaited<ReturnType<typeof getCanonicalStatsApiV1GameBuildsStatsGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCanonicalStatsApiV1GameBuildsStatsGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetCanonicalStatsApiV1GameBuildsStatsGetQueryOptions(
    game,
    options
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Builds context health check.

Args:
    game: Game context (poe1 or poe2).

Returns:
    Health status.
 * @summary builds context healthcheck
 */
export const buildsHealthApiV1GameBuildsHealthGet = (
  game: Game,
  options?: SecondParameter<typeof apiClient>,
  signal?: AbortSignal
) => {
  return apiClient<BuildsHealthApiV1GameBuildsHealthGet200>(
    { url: `/api/v1/${game}/builds/health`, method: 'GET', signal },
    options
  )
}

export const getBuildsHealthApiV1GameBuildsHealthGetQueryKey = (
  game?: Game
) => {
  return [`/api/v1/${game}/builds/health`] as const
}

export const getBuildsHealthApiV1GameBuildsHealthGetQueryOptions = <
  TData = Awaited<ReturnType<typeof buildsHealthApiV1GameBuildsHealthGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof buildsHealthApiV1GameBuildsHealthGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof apiClient>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getBuildsHealthApiV1GameBuildsHealthGetQueryKey(game)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof buildsHealthApiV1GameBuildsHealthGet>>
  > = ({ signal }) =>
    buildsHealthApiV1GameBuildsHealthGet(game, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!game,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof buildsHealthApiV1GameBuildsHealthGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type BuildsHealthApiV1GameBuildsHealthGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof buildsHealthApiV1GameBuildsHealthGet>>
>
export type BuildsHealthApiV1GameBuildsHealthGetQueryError = HTTPValidationError

export function useBuildsHealthApiV1GameBuildsHealthGet<
  TData = Awaited<ReturnType<typeof buildsHealthApiV1GameBuildsHealthGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof buildsHealthApiV1GameBuildsHealthGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof buildsHealthApiV1GameBuildsHealthGet>>,
          TError,
          Awaited<ReturnType<typeof buildsHealthApiV1GameBuildsHealthGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useBuildsHealthApiV1GameBuildsHealthGet<
  TData = Awaited<ReturnType<typeof buildsHealthApiV1GameBuildsHealthGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof buildsHealthApiV1GameBuildsHealthGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof buildsHealthApiV1GameBuildsHealthGet>>,
          TError,
          Awaited<ReturnType<typeof buildsHealthApiV1GameBuildsHealthGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useBuildsHealthApiV1GameBuildsHealthGet<
  TData = Awaited<ReturnType<typeof buildsHealthApiV1GameBuildsHealthGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof buildsHealthApiV1GameBuildsHealthGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary builds context healthcheck
 */

export function useBuildsHealthApiV1GameBuildsHealthGet<
  TData = Awaited<ReturnType<typeof buildsHealthApiV1GameBuildsHealthGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof buildsHealthApiV1GameBuildsHealthGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getBuildsHealthApiV1GameBuildsHealthGetQueryOptions(
    game,
    options
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Rank candidate items against a target item.

Args:
    game: Game context (poe1 or poe2).
    request: Ranking request

Returns:
    Ranked items with scores
 * @summary Rank Items
 */
export const rankItemsApiV1GameAnalysisRankPost = (
  game: Game,
  rankRequest: RankRequest,
  options?: SecondParameter<typeof apiClient>,
  signal?: AbortSignal
) => {
  return apiClient<RankResponse>(
    {
      url: `/api/v1/${game}/analysis/rank`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: rankRequest,
      signal,
    },
    options
  )
}

export const getRankItemsApiV1GameAnalysisRankPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof rankItemsApiV1GameAnalysisRankPost>>,
    TError,
    { game: Game; data: RankRequest },
    TContext
  >
  request?: SecondParameter<typeof apiClient>
}): UseMutationOptions<
  Awaited<ReturnType<typeof rankItemsApiV1GameAnalysisRankPost>>,
  TError,
  { game: Game; data: RankRequest },
  TContext
> => {
  const mutationKey = ['rankItemsApiV1GameAnalysisRankPost']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof rankItemsApiV1GameAnalysisRankPost>>,
    { game: Game; data: RankRequest }
  > = (props) => {
    const { game, data } = props ?? {}

    return rankItemsApiV1GameAnalysisRankPost(game, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type RankItemsApiV1GameAnalysisRankPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof rankItemsApiV1GameAnalysisRankPost>>
>
export type RankItemsApiV1GameAnalysisRankPostMutationBody = RankRequest
export type RankItemsApiV1GameAnalysisRankPostMutationError =
  HTTPValidationError

/**
 * @summary Rank Items
 */
export const useRankItemsApiV1GameAnalysisRankPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof rankItemsApiV1GameAnalysisRankPost>>,
      TError,
      { game: Game; data: RankRequest },
      TContext
    >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof rankItemsApiV1GameAnalysisRankPost>>,
  TError,
  { game: Game; data: RankRequest },
  TContext
> => {
  const mutationOptions =
    getRankItemsApiV1GameAnalysisRankPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Analysis context health check.

Args:
    game: Game context (poe1 or poe2).

Returns:
    Health status.
 * @summary analysis context healthcheck
 */
export const analysisHealthApiV1GameAnalysisHealthGet = (
  game: Game,
  options?: SecondParameter<typeof apiClient>,
  signal?: AbortSignal
) => {
  return apiClient<AnalysisHealthApiV1GameAnalysisHealthGet200>(
    { url: `/api/v1/${game}/analysis/health`, method: 'GET', signal },
    options
  )
}

export const getAnalysisHealthApiV1GameAnalysisHealthGetQueryKey = (
  game?: Game
) => {
  return [`/api/v1/${game}/analysis/health`] as const
}

export const getAnalysisHealthApiV1GameAnalysisHealthGetQueryOptions = <
  TData = Awaited<ReturnType<typeof analysisHealthApiV1GameAnalysisHealthGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof analysisHealthApiV1GameAnalysisHealthGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof apiClient>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getAnalysisHealthApiV1GameAnalysisHealthGetQueryKey(game)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof analysisHealthApiV1GameAnalysisHealthGet>>
  > = ({ signal }) =>
    analysisHealthApiV1GameAnalysisHealthGet(game, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!game,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof analysisHealthApiV1GameAnalysisHealthGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AnalysisHealthApiV1GameAnalysisHealthGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof analysisHealthApiV1GameAnalysisHealthGet>>
>
export type AnalysisHealthApiV1GameAnalysisHealthGetQueryError =
  HTTPValidationError

export function useAnalysisHealthApiV1GameAnalysisHealthGet<
  TData = Awaited<ReturnType<typeof analysisHealthApiV1GameAnalysisHealthGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof analysisHealthApiV1GameAnalysisHealthGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof analysisHealthApiV1GameAnalysisHealthGet>>,
          TError,
          Awaited<ReturnType<typeof analysisHealthApiV1GameAnalysisHealthGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useAnalysisHealthApiV1GameAnalysisHealthGet<
  TData = Awaited<ReturnType<typeof analysisHealthApiV1GameAnalysisHealthGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof analysisHealthApiV1GameAnalysisHealthGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof analysisHealthApiV1GameAnalysisHealthGet>>,
          TError,
          Awaited<ReturnType<typeof analysisHealthApiV1GameAnalysisHealthGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useAnalysisHealthApiV1GameAnalysisHealthGet<
  TData = Awaited<ReturnType<typeof analysisHealthApiV1GameAnalysisHealthGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof analysisHealthApiV1GameAnalysisHealthGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary analysis context healthcheck
 */

export function useAnalysisHealthApiV1GameAnalysisHealthGet<
  TData = Awaited<ReturnType<typeof analysisHealthApiV1GameAnalysisHealthGet>>,
  TError = HTTPValidationError,
>(
  game: Game,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof analysisHealthApiV1GameAnalysisHealthGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getAnalysisHealthApiV1GameAnalysisHealthGetQueryOptions(
    game,
    options
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Basic liveness check endpoint.

This endpoint always returns 200 OK if the application is running.
Use /ready for readiness checks that verify dependencies.

Returns:
    dict[str, str]: Health status.
 * @summary Health Check
 */
export const healthCheckHealthGet = (
  options?: SecondParameter<typeof apiClient>,
  signal?: AbortSignal
) => {
  return apiClient<HealthCheckHealthGet200>(
    { url: `/health`, method: 'GET', signal },
    options
  )
}

export const getHealthCheckHealthGetQueryKey = () => {
  return [`/health`] as const
}

export const getHealthCheckHealthGetQueryOptions = <
  TData = Awaited<ReturnType<typeof healthCheckHealthGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof healthCheckHealthGet>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof apiClient>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getHealthCheckHealthGetQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof healthCheckHealthGet>>
  > = ({ signal }) => healthCheckHealthGet(requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof healthCheckHealthGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type HealthCheckHealthGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof healthCheckHealthGet>>
>
export type HealthCheckHealthGetQueryError = unknown

export function useHealthCheckHealthGet<
  TData = Awaited<ReturnType<typeof healthCheckHealthGet>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof healthCheckHealthGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheckHealthGet>>,
          TError,
          Awaited<ReturnType<typeof healthCheckHealthGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useHealthCheckHealthGet<
  TData = Awaited<ReturnType<typeof healthCheckHealthGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof healthCheckHealthGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheckHealthGet>>,
          TError,
          Awaited<ReturnType<typeof healthCheckHealthGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useHealthCheckHealthGet<
  TData = Awaited<ReturnType<typeof healthCheckHealthGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof healthCheckHealthGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Health Check
 */

export function useHealthCheckHealthGet<
  TData = Awaited<ReturnType<typeof healthCheckHealthGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof healthCheckHealthGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getHealthCheckHealthGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Readiness check endpoint that verifies database and Redis connectivity.

Returns 200 if all dependencies are healthy, 503 otherwise.

Args:
    db: Database session dependency.

Returns:
    dict: Readiness status with individual component health.
 * @summary Readiness Check
 */
export const readinessCheckReadyGet = (
  options?: SecondParameter<typeof apiClient>,
  signal?: AbortSignal
) => {
  return apiClient<unknown>({ url: `/ready`, method: 'GET', signal }, options)
}

export const getReadinessCheckReadyGetQueryKey = () => {
  return [`/ready`] as const
}

export const getReadinessCheckReadyGetQueryOptions = <
  TData = Awaited<ReturnType<typeof readinessCheckReadyGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof readinessCheckReadyGet>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof apiClient>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getReadinessCheckReadyGetQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof readinessCheckReadyGet>>
  > = ({ signal }) => readinessCheckReadyGet(requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof readinessCheckReadyGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadinessCheckReadyGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof readinessCheckReadyGet>>
>
export type ReadinessCheckReadyGetQueryError = unknown

export function useReadinessCheckReadyGet<
  TData = Awaited<ReturnType<typeof readinessCheckReadyGet>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof readinessCheckReadyGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readinessCheckReadyGet>>,
          TError,
          Awaited<ReturnType<typeof readinessCheckReadyGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useReadinessCheckReadyGet<
  TData = Awaited<ReturnType<typeof readinessCheckReadyGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof readinessCheckReadyGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readinessCheckReadyGet>>,
          TError,
          Awaited<ReturnType<typeof readinessCheckReadyGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useReadinessCheckReadyGet<
  TData = Awaited<ReturnType<typeof readinessCheckReadyGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof readinessCheckReadyGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Readiness Check
 */

export function useReadinessCheckReadyGet<
  TData = Awaited<ReturnType<typeof readinessCheckReadyGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof readinessCheckReadyGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof apiClient>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getReadinessCheckReadyGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}
